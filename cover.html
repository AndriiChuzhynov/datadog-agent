
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>daemon: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/DataDog/datadog-agent/pkg/serverless/daemon/daemon.go (51.0%)</option>
				
				<option value="file1">github.com/DataDog/datadog-agent/pkg/serverless/daemon/interval.go (96.2%)</option>
				
				<option value="file2">github.com/DataDog/datadog-agent/pkg/serverless/flush/strategy.go (95.0%)</option>
				
				<option value="file3">github.com/DataDog/datadog-agent/pkg/serverless/logs/logs.go (87.2%)</option>
				
				<option value="file4">github.com/DataDog/datadog-agent/pkg/serverless/metrics/enhanced_metrics.go (100.0%)</option>
				
				<option value="file5">github.com/DataDog/datadog-agent/pkg/serverless/metrics/metric.go (100.0%)</option>
				
				<option value="file6">github.com/DataDog/datadog-agent/pkg/serverless/registration/extension_api.go (100.0%)</option>
				
				<option value="file7">github.com/DataDog/datadog-agent/pkg/serverless/registration/logs_api.go (100.0%)</option>
				
				<option value="file8">github.com/DataDog/datadog-agent/pkg/serverless/registration/logs_api_payload.go (100.0%)</option>
				
				<option value="file9">github.com/DataDog/datadog-agent/pkg/serverless/registration/utils.go (100.0%)</option>
				
				<option value="file10">github.com/DataDog/datadog-agent/pkg/serverless/serverless.go (21.4%)</option>
				
				<option value="file11">github.com/DataDog/datadog-agent/pkg/serverless/tags/tags.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package daemon

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/DataDog/datadog-agent/pkg/config"
        "github.com/DataDog/datadog-agent/pkg/logs"
        logConfig "github.com/DataDog/datadog-agent/pkg/logs/config"
        "github.com/DataDog/datadog-agent/pkg/serverless/flush"
        serverlessLog "github.com/DataDog/datadog-agent/pkg/serverless/logs"
        "github.com/DataDog/datadog-agent/pkg/serverless/metrics"
        "github.com/DataDog/datadog-agent/pkg/serverless/tags"
        traceAgent "github.com/DataDog/datadog-agent/pkg/trace/agent"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

// httpServerPort will be the default port used to run the HTTP server listening
// to calls from the client libraries and to logs from the AWS environment.
const httpServerPort int = 8124

// shutdownDelay is the amount of time we wait before shutting down the HTTP server
// after we receive a Shutdown event. This allows time for the final log messages
// to arrive from the Logs API.
const shutdownDelay time.Duration = 1 * time.Second

// Daemon is the communcation server for between the runtime and the serverless Agent.
// The name "daemon" is just in order to avoid serverless.StartServer ...
type Daemon struct {
        httpServer *http.Server
        mux        *http.ServeMux

        MetricAgent *metrics.ServerlessMetricAgent

        traceAgent *traceAgent.Agent

        // lastInvocations stores last invocation times to be able to compute the
        // interval of invocation of the function.
        LastInvocations []time.Time

        // flushStrategy is the currently selected flush strategy, defaulting to the
        // the "flush at the end" naive strategy.
        FlushStrategy flush.Strategy

        // useAdaptiveFlush is set to false when the flush strategy has been forced
        // through configuration.
        useAdaptiveFlush bool

        // ClientLibReady indicates whether the datadog client library has initialised
        // and called the /hello route on the agent
        ClientLibReady bool

        // stopped represents whether the Daemon has been stopped
        stopped bool

        // Wait on this WaitGroup to be sure that the daemon isn't doing any pending
        // work before finishing an invocation
        InvcWg *sync.WaitGroup

        ExtraTags *serverlessLog.Tags

        ExecutionContext *serverlessLog.ExecutionContext

        // finishInvocationOnce assert that FinishedInvocation will be called only once (at the end of the function OR after a timeout)
        // this should be reset before each invocation
        FinishInvocationOnce sync.Once

        ARN           *string
        LastRequestID *string
}

// Hello implements the basic Hello route, creating a way for the Datadog Lambda Library
// to know that the serverless agent is running. It is blocking until the DogStatsD daemon is ready.
type Hello struct {
        daemon *Daemon
}

// ServeHTTP - see type Hello comment.
func (h *Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Debug("Hit on the serverless.Hello route.")
        // if the DogStatsD daemon isn't ready, wait for it.
        h.daemon.ClientLibReady = true
}</span>

// Flush is the route to call to do an immediate flush on the serverless agent.
// Returns 503 if the DogStatsD is not ready yet, 200 otherwise.
type Flush struct {
        daemon *Daemon
}

// ServeHTTP - see type Flush comment.
func (f *Flush) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Debug("Hit on the serverless.Flush route.")
        if !f.daemon.FlushStrategy.ShouldFlush(flush.Stopping, time.Now()) </span><span class="cov0" title="0">{
                log.Debug("The flush strategy", f.daemon.FlushStrategy, " has decided to not flush in moment:", flush.Stopping)
                f.daemon.FinishInvocation()
                return
        }</span>

        <span class="cov0" title="0">log.Debug("The flush strategy", f.daemon.FlushStrategy, " has decided to flush in moment:", flush.Stopping)

        // if the DogStatsD daemon isn't ready, wait for it.
        if f.daemon.MetricAgent.DogStatDServer == nil </span><span class="cov0" title="0">{
                w.WriteHeader(503)
                w.Write([]byte("DogStatsD server not ready"))
                f.daemon.FinishInvocation()
                return
        }</span>

        // note that I am not using the request context because I think that we don't
        // want the flush to be canceled if the client is closing the request.
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                flushTimeout := config.Datadog.GetDuration("forwarder_timeout") * time.Second
                ctx, cancel := context.WithTimeout(context.Background(), flushTimeout)
                f.daemon.TriggerFlush(ctx, false)
                f.daemon.FinishInvocation()
                cancel()
        }</span>()

}

//SetMuxHandle configures the log collection route handler
func (d *Daemon) SetMuxHandle(route string, logsChan chan *logConfig.ChannelMessage, logsEnabled bool, enhancedMetricsEnabled bool) <span class="cov0" title="0">{
        fmt.Println("IN MUX HANDLE")
        fmt.Printf("ROUTE = %v \n", route)
        fmt.Printf("d.ExtraTags = %v \n", d.ExtraTags)
        fmt.Printf("logsChan = %v \n", logsChan)
        fmt.Printf("d.MetricAgent = %v \n", d.MetricAgent)

        d.mux.Handle(route, &amp;serverlessLog.LogsCollection{
                ExtraTags:              d.ExtraTags,
                ExecutionContext:       d.ExecutionContext,
                LogChannel:             logsChan,
                MetricChannel:          d.MetricAgent.Aggregator.GetBufferedMetricsWithTsChannel(),
                LogsEnabled:            logsEnabled,
                EnhancedMetricsEnabled: enhancedMetricsEnabled,
        })
}</span>

// SetStatsdServer sets the DogStatsD server instance running when it is ready.
func (d *Daemon) SetStatsdServer(metricAgent *metrics.ServerlessMetricAgent) <span class="cov0" title="0">{
        d.MetricAgent = metricAgent
}</span>

// SetTraceAgent sets the Agent instance for submitting traces
func (d *Daemon) SetTraceAgent(traceAgent *traceAgent.Agent) <span class="cov0" title="0">{
        d.traceAgent = traceAgent
}</span>

// SetFlushStrategy sets the flush strategy to use.
func (d *Daemon) SetFlushStrategy(strategy flush.Strategy) <span class="cov0" title="0">{
        log.Debugf("Set flush strategy: %s (was: %s)", strategy.String(), d.FlushStrategy.String())
        d.FlushStrategy = strategy
}</span>

// UseAdaptiveFlush sets whether we use the adaptive flush or not.
// Set it to false when the flush strategy has been forced through configuration.
func (d *Daemon) UseAdaptiveFlush(enabled bool) <span class="cov0" title="0">{
        d.useAdaptiveFlush = enabled
}</span>

// TriggerFlush triggers a flush of the aggregated metrics, traces and logs.
// They are flushed concurrently.
// In some circumstances, it may switch to another flush strategy after the flush.
// isLastFlush indicates whether this is the last flush before the shutdown or not.
func (d *Daemon) TriggerFlush(ctx context.Context, isLastFlush bool) <span class="cov8" title="1">{
        // Increment the invocation wait group which tracks whether work is in progress for the daemon
        d.InvcWg.Add(1)
        defer d.InvcWg.Done()
        wg := sync.WaitGroup{}
        wg.Add(1)
        wg.Add(1)
        wg.Add(1)

        // metrics
        go func() </span><span class="cov8" title="1">{
                if d.MetricAgent != nil &amp;&amp; d.MetricAgent.DogStatDServer != nil </span><span class="cov0" title="0">{
                        d.MetricAgent.DogStatDServer.Flush()
                }</span>
                <span class="cov8" title="1">wg.Done()</span>
        }()

        // traces
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if d.traceAgent != nil </span><span class="cov0" title="0">{
                        d.traceAgent.FlushSync()
                }</span>
                <span class="cov8" title="1">wg.Done()</span>
        }()

        // logs
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                logs.Flush(ctx)
                wg.Done()
        }</span>()

        <span class="cov8" title="1">wg.Wait()
        log.Debug("Flush done")

        // After flushing, re-evaluate flush strategy (if applicable)
        if !isLastFlush </span><span class="cov0" title="0">{
                d.UpdateStrategy()
        }</span>
}

// Stop causes the Daemon to gracefully shut down. After a delay, the HTTP server
// is shut down, data is flushed a final time, and then the agents are shut down.
func (d *Daemon) Stop(isTimeout bool) <span class="cov8" title="1">{
        // Can't shut down before starting
        // If the DogStatsD daemon isn't ready, wait for it.

        if d.stopped </span><span class="cov0" title="0">{
                log.Debug("Daemon.Stop() was called, but Daemon was already stopped")
                return
        }</span>
        <span class="cov8" title="1">d.stopped = true

        if !isTimeout </span><span class="cov8" title="1">{
                // Wait for any remaining logs to arrive via the logs API before shutting down the HTTP server
                log.Debug("Waiting to shut down HTTP server")
                time.Sleep(shutdownDelay)
        }</span>

        <span class="cov8" title="1">log.Debug("Shutting down HTTP server")
        err := d.httpServer.Shutdown(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error shutting down HTTP server")
        }</span>

        // Once the HTTP server is shut down, it is safe to shut down the agents
        // Otherwise, we might try to handle API calls after the agent has already been shut down
        <span class="cov8" title="1">d.TriggerFlush(context.Background(), true)

        log.Debug("Shutting down agents")

        if d.MetricAgent != nil &amp;&amp; d.MetricAgent.DogStatDServer != nil </span><span class="cov0" title="0">{
                d.MetricAgent.DogStatDServer.Stop()
        }</span>
        <span class="cov8" title="1">logs.Stop()
        log.Debug("Serverless agent shutdown complete")</span>
}

// StartDaemon starts an HTTP server to receive messages from the runtime.
// The DogStatsD server is provided when ready (slightly later), to have the
// hello route available as soon as possible. However, the HELLO route is blocking
// to have a way for the runtime function to know when the Serverless Agent is ready.
// If the Flush route is called before the statsd server has been set, a 503
// is returned by the HTTP route.
func StartDaemon() *Daemon <span class="cov8" title="1">{
        log.Debug("Starting daemon to receive messages from runtime...")
        mux := http.NewServeMux()

        daemon := &amp;Daemon{
                httpServer:       &amp;http.Server{Addr: fmt.Sprintf(":%d", httpServerPort), Handler: mux},
                mux:              mux,
                InvcWg:           &amp;sync.WaitGroup{},
                LastInvocations:  make([]time.Time, 0),
                useAdaptiveFlush: true,
                ClientLibReady:   false,
                FlushStrategy:    &amp;flush.AtTheEnd{},
                ExtraTags:        &amp;serverlessLog.Tags{},
                ExecutionContext: &amp;serverlessLog.ExecutionContext{},
        }

        log.Debug("Adaptive flush is enabled")

        mux.Handle("/lambda/hello", &amp;Hello{daemon})
        mux.Handle("/lambda/flush", &amp;Flush{daemon})

        // start the HTTP server used to communicate with the clients
        go func() </span><span class="cov8" title="1">{
                if err := daemon.httpServer.ListenAndServe(); err != nil </span><span class="cov8" title="1">{
                        log.Error(err)
                }</span>
        }()

        <span class="cov8" title="1">return daemon</span>
}

// StartInvocation tells the daemon the invocation began
func (d *Daemon) StartInvocation() <span class="cov8" title="1">{
        d.InvcWg.Add(1)
}</span>

// FinishInvocation finishes the current invocation
func (d *Daemon) FinishInvocation() <span class="cov8" title="1">{
        d.FinishInvocationOnce.Do(func() </span><span class="cov8" title="1">{
                d.InvcWg.Done()
        }</span>)
}

// WaitForDaemon waits until invocation finished any pending work
func (d *Daemon) WaitForDaemon() <span class="cov8" title="1">{
        if d.ClientLibReady </span><span class="cov8" title="1">{
                d.InvcWg.Wait()
        }</span>
}

// WaitUntilClientReady will wait until the client library has called the /hello route, or timeout
func (d *Daemon) WaitUntilClientReady(timeout time.Duration) bool <span class="cov8" title="1">{
        checkInterval := 10 * time.Millisecond
        for timeout &gt; checkInterval </span><span class="cov8" title="1">{
                if d.ClientLibReady </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">&lt;-time.After(checkInterval)
                timeout -= checkInterval</span>
        }
        <span class="cov8" title="1">&lt;-time.After(timeout)
        return d.ClientLibReady</span>
}

// ComputeGlobalTags extracts tags from the ARN, merges them with any user-defined tags and adds them to traces, logs and metrics
func (d *Daemon) ComputeGlobalTags(arn string, configTags []string) <span class="cov0" title="0">{
        if len(d.ExtraTags.Tags) == 0 </span><span class="cov0" title="0">{
                tagMap := tags.BuildTagMap(arn, configTags)
                tagArray := tags.BuildTagsFromMap(tagMap)
                if d.MetricAgent != nil &amp;&amp; d.MetricAgent.DogStatDServer != nil </span><span class="cov0" title="0">{
                        d.MetricAgent.DogStatDServer.SetExtraTags(tagArray)
                }</span>
                <span class="cov0" title="0">if d.traceAgent != nil </span><span class="cov0" title="0">{
                        d.traceAgent.SetGlobalTags(tags.BuildTracerTags(tagMap))
                }</span>
                <span class="cov0" title="0">d.ExtraTags.Tags = tagArray
                source := serverlessLog.GetLambdaSource()
                if source != nil </span><span class="cov0" title="0">{
                        source.Config.Tags = tagArray
                }</span>
        }
}

func (d *Daemon) SetExecutionContext(arn string, requestID string) <span class="cov0" title="0">{
        d.ExecutionContext.ARN = arn
        d.ExecutionContext.LastRequestID = requestID
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package daemon

import (
        "time"

        "github.com/DataDog/datadog-agent/pkg/serverless/flush"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

const maxInvocationsStored = 10

// StoreInvocationTime stores the given invocation time in the list of previous
// invocations. It is used to compute the invocation interval of the current function.
// It is automatically removing entries when too much have been already stored (more than maxInvocationsStored).
// When trying to store a new point, if it is older than the last one stored, it is ignored.
// Returns if the point has been stored.
func (d *Daemon) StoreInvocationTime(t time.Time) bool <span class="cov8" title="1">{
        // ignore points older than the last stored one
        if len(d.LastInvocations) &gt; 0 &amp;&amp; d.LastInvocations[len(d.LastInvocations)-1].After(t) </span><span class="cov0" title="0">{
                return false
        }</span>

        // remove when too much/old entries
        <span class="cov8" title="1">d.LastInvocations = append(d.LastInvocations, t)
        if len(d.LastInvocations) &gt; maxInvocationsStored </span><span class="cov8" title="1">{
                d.LastInvocations = d.LastInvocations[len(d.LastInvocations)-maxInvocationsStored : len(d.LastInvocations)]
        }</span>

        <span class="cov8" title="1">return true</span>
}

// InvocationInterval computes the invocation interval of the current function.
// This function returns 0 if not enough invocations were done.
func (d *Daemon) InvocationInterval() time.Duration <span class="cov8" title="1">{
        // with less than 3 invocations, we don't have enough data to compute
        // something reliable.
        if len(d.LastInvocations) &lt; 3 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var total int64
        for i := 1; i &lt; len(d.LastInvocations); i++ </span><span class="cov8" title="1">{
                total += int64(d.LastInvocations[i].Sub(d.LastInvocations[i-1]))
        }</span>

        <span class="cov8" title="1">return time.Duration(total / int64(len(d.LastInvocations)-1))</span>
}

// AutoSelectStrategy uses the invocation interval of the function to select the
// best flush strategy.
// This function doesn't mind if the flush strategy has been overridden through
// configuration / environment var, the caller is responsible of that.
func (d *Daemon) AutoSelectStrategy() flush.Strategy <span class="cov8" title="1">{
        flushInterval := 10 * time.Second
        freq := d.InvocationInterval()

        if !d.ClientLibReady </span><span class="cov8" title="1">{
                return flush.NewPeriodically(flushInterval)
        }</span>

        // when not enough data is available, fallback on flush.AtTheEnd strategy
        <span class="cov8" title="1">if freq == time.Duration(0) </span><span class="cov8" title="1">{
                return &amp;flush.AtTheEnd{}
        }</span>

        // if running more than 1 time every 5 minutes, we can switch to the flush strategy
        // flushing at least every 10 seconds (at the start of the invocation)
        // TODO(remy): compute a proper interval instead of hard-coding 10 seconds
        <span class="cov8" title="1">if freq.Seconds() &lt; 60*5 </span><span class="cov8" title="1">{
                return flush.NewPeriodically(flushInterval)
        }</span>

        <span class="cov8" title="1">return &amp;flush.AtTheEnd{}</span>
}

// UpdateStrategy will update the current flushing strategy
func (d *Daemon) UpdateStrategy() <span class="cov8" title="1">{
        if d.useAdaptiveFlush </span><span class="cov8" title="1">{
                newStrat := d.AutoSelectStrategy()
                if newStrat.String() != d.FlushStrategy.String() </span><span class="cov8" title="1">{
                        log.Debug("Switching to flush strategy:", newStrat)
                        d.FlushStrategy = newStrat
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package flush

import (
        "fmt"
        "strconv"
        "strings"
        "time"
)

// Strategy is deciding whether the data should be flushed or not at the given moment.
type Strategy interface {
        String() string
        ShouldFlush(moment Moment, t time.Time) bool
}

// Moment represents at which moment we're asking the flush strategy if we
// should flush or not.
// Note that there is no entry for the shutdown of the environment because we always
// flush in this situation.
type Moment string

const (
        // Starting is used to represent the moment the function is starting because
        // it has been invoked.
        Starting Moment = "starting"
        // Stopping is used to represent the moment right after the function has finished
        // its execution.
        Stopping Moment = "stopping"
)

// StrategyFromString returns a flush strategy from the given string.
// Possible values:
//   - end
//   - periodically[,milliseconds]
func StrategyFromString(str string) (Strategy, error) <span class="cov8" title="1">{
        switch str </span>{
        case "end":<span class="cov8" title="1">
                return &amp;AtTheEnd{}, nil</span>
        case "periodically":<span class="cov8" title="1">
                return NewPeriodically(10 * time.Second), nil</span>
        }

        <span class="cov8" title="1">if strings.HasPrefix(str, "periodically") &amp;&amp; strings.Count(str, ",") == 1 </span><span class="cov8" title="1">{
                parts := strings.Split(str, ",")

                msecs, err := strconv.Atoi(parts[1])
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;AtTheEnd{}, fmt.Errorf("StrategyFromString: can't parse flush strategy: %s", str)
                }</span>

                <span class="cov8" title="1">return NewPeriodically(time.Duration(msecs) * time.Millisecond), nil</span>
        }

        <span class="cov8" title="1">return &amp;AtTheEnd{}, fmt.Errorf("StrategyFromString: can't parse flush strategy: %s", str)</span>
}

// -----

// AtTheEnd strategy is the simply flushing the data at the end of the execution of the function.
type AtTheEnd struct{}

func (s *AtTheEnd) String() string <span class="cov8" title="1">{ return "end" }</span>

// ShouldFlush returns true if this strategy want to flush at the given moment.
func (s *AtTheEnd) ShouldFlush(moment Moment, t time.Time) bool <span class="cov8" title="1">{
        return moment == Stopping
}</span>

// Periodically is the strategy flushing at least every N [nano/micro/milli]seconds
// at the start of the function.
type Periodically struct {
        interval  time.Duration
        lastFlush time.Time
}

// NewPeriodically returns an initialized Periodically flush strategy.
func NewPeriodically(interval time.Duration) *Periodically <span class="cov8" title="1">{
        return &amp;Periodically{interval: interval}
}</span>

func (s *Periodically) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("periodically,%d", s.interval/time.Millisecond)
}</span>

// ShouldFlush returns true if this strategy want to flush at the given moment.
func (s *Periodically) ShouldFlush(moment Moment, t time.Time) bool <span class="cov8" title="1">{
        if moment == Starting </span><span class="cov8" title="1">{
                now := time.Now()
                if s.lastFlush.Add(s.interval).Before(now) </span><span class="cov8" title="1">{
                        s.lastFlush = now
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package logs

import (
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"
        "time"

        "github.com/DataDog/datadog-agent/cmd/agent/common"
        "github.com/DataDog/datadog-agent/pkg/autodiscovery"
        "github.com/DataDog/datadog-agent/pkg/logs"
        logConfig "github.com/DataDog/datadog-agent/pkg/logs/config"
        "github.com/DataDog/datadog-agent/pkg/logs/scheduler"
        "github.com/DataDog/datadog-agent/pkg/metrics"
        serverlessMetrics "github.com/DataDog/datadog-agent/pkg/serverless/metrics"
        "github.com/DataDog/datadog-agent/pkg/serverless/tags"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

type Tags struct {
        Tags []string
}

type ExecutionContext struct {
        ARN           string
        LastRequestID string
}

// LogsCollection is the route on which the AWS environment is sending the logs
// for the extension to collect them. It is attached to the main HTTP server
// already receiving hits from the libraries client.
type LogsCollection struct {
        LogChannel             chan *logConfig.ChannelMessage
        MetricChannel          chan []metrics.MetricSample
        ExtraTags              *Tags
        ExecutionContext       *ExecutionContext
        LogsEnabled            bool
        EnhancedMetricsEnabled bool
}

// logMessageTimeLayout is the layout string used to format timestamps from logs
const logMessageTimeLayout = "2006-01-02T15:04:05.999Z"

const (
        // LogTypeExtension is used to represent logs messages emitted by extensions
        LogTypeExtension = "extension"

        // LogTypeFunction is used to represent logs messages emitted by the function
        LogTypeFunction = "function"

        // LogTypePlatformStart is used for the log message about the platform starting
        LogTypePlatformStart = "platform.start"
        // LogTypePlatformEnd is used for the log message about the platform shutting down
        LogTypePlatformEnd = "platform.end"
        // LogTypePlatformReport is used for the log messages containing a report of the last invocation.
        LogTypePlatformReport = "platform.report"
        // LogTypePlatformLogsDropped is used when AWS has dropped logs because we were unable to consume them fast enough.
        LogTypePlatformLogsDropped = "platform.logsDropped"
        // LogTypePlatformLogsSubscription is used for the log messages about Logs API registration
        LogTypePlatformLogsSubscription = "platform.logsSubscription"
        // LogTypePlatformExtension is used for the log messages about Extension API registration
        LogTypePlatformExtension = "platform.extension"
)

// LogMessage is a log message sent by the AWS API.
type LogMessage struct {
        Time time.Time
        ARN  string
        Type string
        // "extension" / "function" log messages contain a record which is basically a log string
        StringRecord string `json:"record"`
        ObjectRecord serverlessMetrics.PlatformObjectRecord
}

// UnmarshalJSON unmarshals the given bytes in a LogMessage object.
func (l *LogMessage) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var j map[string]interface{}
        if err := json.Unmarshal(data, &amp;j); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("LogMessage.UnmarshalJSON: can't unmarshal json: %s", err)
        }</span>

        <span class="cov8" title="1">var typ string
        var ok bool

        // type

        if typ, ok = j["type"].(string); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("LogMessage.UnmarshalJSON: malformed log message")
        }</span>

        // time

        <span class="cov8" title="1">if timeStr, ok := j["time"].(string); ok </span><span class="cov8" title="1">{
                if time, err := time.Parse(logMessageTimeLayout, timeStr); err == nil </span><span class="cov8" title="1">{
                        l.Time = time
                }</span>
        }

        // the rest

        <span class="cov8" title="1">switch typ </span>{
        case LogTypePlatformLogsSubscription, LogTypePlatformExtension:<span class="cov0" title="0">
                l.Type = typ</span>
        case LogTypeFunction, LogTypeExtension:<span class="cov8" title="1">
                l.Type = typ
                l.StringRecord = j["record"].(string)</span>
        case LogTypePlatformStart, LogTypePlatformEnd, LogTypePlatformReport:<span class="cov8" title="1">
                l.Type = typ
                if objectRecord, ok := j["record"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // all of these have the requestId
                        if requestID, ok := objectRecord["requestId"].(string); ok </span><span class="cov8" title="1">{
                                l.ObjectRecord.RequestID = requestID
                        }</span>

                        <span class="cov8" title="1">switch typ </span>{
                        case LogTypePlatformStart:<span class="cov0" title="0">
                                if version, ok := objectRecord["version"].(string); ok </span><span class="cov0" title="0">{
                                        l.ObjectRecord.Version = version
                                }</span>
                                <span class="cov0" title="0">l.StringRecord = fmt.Sprintf("START RequestId: %s Version: %s",
                                        l.ObjectRecord.RequestID,
                                        l.ObjectRecord.Version,
                                )</span>
                        case LogTypePlatformEnd:<span class="cov0" title="0">
                                l.StringRecord = fmt.Sprintf("END RequestId: %s",
                                        l.ObjectRecord.RequestID,
                                )</span>
                        case LogTypePlatformReport:<span class="cov8" title="1">
                                if metrics, ok := objectRecord["metrics"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        if v, ok := metrics["durationMs"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.DurationMs = v
                                        }</span>
                                        <span class="cov8" title="1">if v, ok := metrics["billedDurationMs"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.BilledDurationMs = int(v)
                                        }</span>
                                        <span class="cov8" title="1">if v, ok := metrics["memorySizeMB"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.MemorySizeMB = int(v)
                                        }</span>
                                        <span class="cov8" title="1">if v, ok := metrics["maxMemoryUsedMB"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.MaxMemoryUsedMB = int(v)
                                        }</span>
                                        <span class="cov8" title="1">if v, ok := metrics["initDurationMs"].(float64); ok </span><span class="cov8" title="1">{
                                                l.ObjectRecord.Metrics.InitDurationMs = v
                                        }</span>
                                        <span class="cov8" title="1">log.Debugf("Enhanced metrics: %+v\n", l.ObjectRecord.Metrics)</span>
                                } else<span class="cov0" title="0"> {
                                        log.Error("LogMessage.UnmarshalJSON: can't read the metrics object")
                                }</span>
                                <span class="cov8" title="1">l.StringRecord = createStringRecordForReportLog(l)</span>
                        }
                } else<span class="cov0" title="0"> {
                        log.Error("LogMessage.UnmarshalJSON: can't read the record object")
                }</span>
        default:<span class="cov0" title="0"></span>
                // we're not parsing this kind of message yet
        }

        <span class="cov8" title="1">return nil</span>
}

// ShouldProcessLog returns whether or not the log should be further processed.
func shouldProcessLog(executionContext *ExecutionContext, message LogMessage) bool <span class="cov8" title="1">{
        // If the global request ID or ARN variable isn't set at this point, do not process further
        if len(executionContext.ARN) == 0 || len(executionContext.LastRequestID) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        // Making sure that we do not process these types of logs since they are not tied to specific invovations
        <span class="cov8" title="1">if message.Type == LogTypePlatformExtension || message.Type == LogTypePlatformLogsSubscription </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func createStringRecordForReportLog(l *LogMessage) string <span class="cov8" title="1">{
        stringRecord := fmt.Sprintf("REPORT RequestId: %s\tDuration: %.2f ms\tBilled Duration: %d ms\tMemory Size: %d MB\tMax Memory Used: %d MB",
                l.ObjectRecord.RequestID,
                l.ObjectRecord.Metrics.DurationMs,
                l.ObjectRecord.Metrics.BilledDurationMs,
                l.ObjectRecord.Metrics.MemorySizeMB,
                l.ObjectRecord.Metrics.MaxMemoryUsedMB,
        )
        if l.ObjectRecord.Metrics.InitDurationMs &gt; 0 </span><span class="cov8" title="1">{
                stringRecord = stringRecord + fmt.Sprintf("\tInit Duration: %.2f ms", l.ObjectRecord.Metrics.InitDurationMs)
        }</span>

        <span class="cov8" title="1">return stringRecord</span>
}

// ParseLogsAPIPayload transforms the payload received from the Logs API to an array of LogMessage
func parseLogsAPIPayload(data []byte) ([]LogMessage, error) <span class="cov8" title="1">{
        var messages []LogMessage
        if err := json.Unmarshal(data, &amp;messages); err != nil </span><span class="cov8" title="1">{
                // Temporary fix to handle malformed JSON tracing object : retry with sanitization
                log.Debug("Can't read log message, retry with sanitization")
                sanitizedData := removeInvalidTracingItem(data)
                if err := json.Unmarshal(sanitizedData, &amp;messages); err != nil </span><span class="cov8" title="1">{
                        fmt.Println(err)
                        return nil, errors.New("can't read log message")
                }</span>
                <span class="cov8" title="1">return messages, nil</span>
        }
        <span class="cov8" title="1">return messages, nil</span>
}

// removeInvalidTracingItem is a temporary fix to handle malformed JSON tracing object
func removeInvalidTracingItem(data []byte) []byte <span class="cov8" title="1">{
        return []byte(strings.ReplaceAll(string(data), ",\"tracing\":}", ""))
}</span>

// GetLambdaSource returns the LogSource used by the extension
func GetLambdaSource() *logConfig.LogSource <span class="cov8" title="1">{
        currentScheduler := scheduler.GetScheduler()
        if currentScheduler != nil </span><span class="cov8" title="1">{
                source := currentScheduler.GetSourceFromName("lambda")
                if source != nil </span><span class="cov8" title="1">{
                        return source
                }</span>
        }
        <span class="cov8" title="1">log.Debug("Impossible to retrieve the lambda LogSource")
        return nil</span>
}

// ServeHTTP - see type LogsCollection comment.
func (l *LogsCollection) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        data, _ := ioutil.ReadAll(r.Body)
        defer r.Body.Close()
        log.Debug("xxx - in serve http parsing")
        messages, err := parseLogsAPIPayload(data)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err)
                log.Debug("xxx - in serve http parsing 400")
                w.WriteHeader(400)
        }</span> else<span class="cov8" title="1"> {
                processLogMessages(l, messages)
                log.Debug("xxx - in serve http parsing 200")
                w.WriteHeader(200)
        }</span>
}

func processLogMessages(l *LogsCollection, messages []LogMessage) <span class="cov8" title="1">{
        metricTags := tags.AddColdStartTag(l.ExtraTags.Tags, len(l.ExecutionContext.LastRequestID) == 0)
        for _, message := range messages </span><span class="cov8" title="1">{
                processMessage(message, l.ExecutionContext, l.EnhancedMetricsEnabled, metricTags, l.MetricChannel)
                // We always collect and process logs for the purpose of extracting enhanced metrics.
                // However, if logs are not enabled, we do not send them to the intake.
                if l.LogsEnabled </span><span class="cov8" title="1">{
                        logMessage := logConfig.NewChannelMessageFromLambda([]byte(message.StringRecord), message.Time, l.ExecutionContext.ARN, l.ExecutionContext.LastRequestID)
                        l.LogChannel &lt;- logMessage
                }</span>
        }
}

// ProcessMessage performs logic about metrics and tags on the message
func processMessage(message LogMessage, executionContext *ExecutionContext, enhancedMetricsEnabled bool, metricTags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        // Do not send logs or metrics if we can't associate them with an ARN or Request ID
        if !shouldProcessLog(executionContext, message) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if enhancedMetricsEnabled </span><span class="cov8" title="1">{
                if message.Type == LogTypeFunction </span><span class="cov8" title="1">{
                        serverlessMetrics.GenerateEnhancedMetricsFromFunctionLog(message.StringRecord, message.Time, metricTags, metricsChan)
                }</span>
                <span class="cov8" title="1">if message.Type == LogTypePlatformReport </span><span class="cov8" title="1">{
                        serverlessMetrics.GenerateEnhancedMetricsFromReportLog(message.ObjectRecord, message.Time, metricTags, metricsChan)
                }</span>
        }

        <span class="cov8" title="1">if message.Type == LogTypePlatformLogsDropped </span><span class="cov8" title="1">{
                log.Debug("Logs were dropped by the AWS Lambda Logs API")
        }</span>
}

func SetupLogAgent(logChannel chan *logConfig.ChannelMessage) <span class="cov0" title="0">{
        // we subscribed to the logs collection on the platform, let's instantiate
        // a logs agent to collect/process/flush the logs.
        if err := logs.StartServerless(
                func() *autodiscovery.AutoConfig </span><span class="cov0" title="0">{ return common.AC }</span>,
                logChannel, nil,
        ); err != nil <span class="cov0" title="0">{
                log.Error("Could not start an instance of the Logs Agent:", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package metrics

import (
        "math"
        "strings"
        "time"

        "github.com/DataDog/datadog-agent/pkg/metrics"
)

// Latest Lambda pricing per https://aws.amazon.com/lambda/pricing/
const (
        baseLambdaInvocationPrice = 0.0000002
        lambdaPricePerGbSecond    = 0.0000166667
        msToSec                   = 0.001
)

func getOutOfMemorySubstrings() []string <span class="cov8" title="1">{
        return []string{
                "fatal error: runtime: out of memory",       // Go
                "java.lang.OutOfMemoryError",                // Java
                "JavaScript heap out of memory",             // Node
                "Runtime exited with error: signal: killed", // Node
                "MemoryError", // Python
                "failed to allocate memory (NoMemoryError)", // Ruby
        }
}</span>

// GenerateEnhancedMetricsFromRegularLog generates enhanced metrics from a LogTypeFunction message
func GenerateEnhancedMetricsFromFunctionLog(logString string, time time.Time, tags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        for _, substring := range getOutOfMemorySubstrings() </span><span class="cov8" title="1">{
                if strings.Contains(logString, substring) </span><span class="cov8" title="1">{
                        metricsChan &lt;- []metrics.MetricSample{{
                                Name:       "aws.lambda.enhanced.out_of_memory",
                                Value:      1.0,
                                Mtype:      metrics.DistributionType,
                                Tags:       tags,
                                SampleRate: 1,
                                Timestamp:  float64(time.UnixNano()),
                        }}
                        return
                }</span>
        }
}

// GenerateEnhancedMetricsFromReportLog generates enhanced metrics from a LogTypePlatformReport log message
func GenerateEnhancedMetricsFromReportLog(objectRecord PlatformObjectRecord, time time.Time, tags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        memorySizeMb := float64(objectRecord.Metrics.MemorySizeMB)
        billedDurationMs := float64(objectRecord.Metrics.BilledDurationMs)
        timestamp := float64(time.UnixNano())
        enhancedMetrics := []metrics.MetricSample{{
                Name:       "aws.lambda.enhanced.max_memory_used",
                Value:      float64(objectRecord.Metrics.MaxMemoryUsedMB),
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  timestamp,
        }, {
                Name:       "aws.lambda.enhanced.memorysize",
                Value:      memorySizeMb,
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  timestamp,
        }, {
                Name:       "aws.lambda.enhanced.billed_duration",
                Value:      billedDurationMs * msToSec,
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  timestamp,
        }, {
                Name:       "aws.lambda.enhanced.duration",
                Value:      objectRecord.Metrics.DurationMs * msToSec,
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  timestamp,
        }, {
                Name:       "aws.lambda.enhanced.estimated_cost",
                Value:      calculateEstimatedCost(billedDurationMs, memorySizeMb),
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  timestamp,
        }}
        if objectRecord.Metrics.InitDurationMs &gt; 0 </span><span class="cov8" title="1">{
                initDurationMetric := metrics.MetricSample{
                        Name:       "aws.lambda.enhanced.init_duration",
                        Value:      objectRecord.Metrics.InitDurationMs * msToSec,
                        Mtype:      metrics.DistributionType,
                        Tags:       tags,
                        SampleRate: 1,
                        Timestamp:  timestamp,
                }
                enhancedMetrics = append(enhancedMetrics, initDurationMetric)
        }</span>
        <span class="cov8" title="1">metricsChan &lt;- enhancedMetrics</span>
}

// sendTimeoutEnhancedMetric sends an enhanced metric representing a timeout
func SendTimeoutEnhancedMetric(tags []string, metricsChan chan []metrics.MetricSample) <span class="cov8" title="1">{
        metricsChan &lt;- []metrics.MetricSample{{
                Name:       "aws.lambda.enhanced.timeouts",
                Value:      1.0,
                Mtype:      metrics.DistributionType,
                Tags:       tags,
                SampleRate: 1,
                Timestamp:  float64(time.Now().UnixNano()),
        }}
}</span>

// calculateEstimatedCost returns the estimated cost in USD of a Lambda invocation
func calculateEstimatedCost(billedDurationMs float64, memorySizeMb float64) float64 <span class="cov8" title="1">{
        billedDurationSeconds := billedDurationMs / 1000.0
        memorySizeGb := memorySizeMb / 1024.0
        gbSeconds := billedDurationSeconds * memorySizeGb
        // round the final float result because float math could have float point imprecision
        // on some arch. (i.e. 1.00000000000002 values)
        return math.Round((baseLambdaInvocationPrice+(gbSeconds*lambdaPricePerGbSecond))*10e12) / 10e12
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package metrics

import (
        "time"

        "github.com/DataDog/datadog-agent/pkg/aggregator"
        "github.com/DataDog/datadog-agent/pkg/config"
        "github.com/DataDog/datadog-agent/pkg/dogstatsd"
        "github.com/DataDog/datadog-agent/pkg/forwarder"
        "github.com/DataDog/datadog-agent/pkg/serializer"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

// PlatformObjectRecord contains additional information found in Platform log messages
type PlatformObjectRecord struct {
        RequestID string           // uuid; present in LogTypePlatform{Start,End,Report}
        Version   string           // present in LogTypePlatformStart only
        Metrics   ReportLogMetrics // present in LogTypePlatformReport only
}

// ReportLogMetrics contains metrics found in a LogTypePlatformReport log
type ReportLogMetrics struct {
        DurationMs       float64
        BilledDurationMs int
        MemorySizeMB     int
        MaxMemoryUsedMB  int
        InitDurationMs   float64
}

type ServerlessMetricAgent struct {
        DogStatDServer *dogstatsd.Server
        Aggregator     *aggregator.BufferedAggregator
}

type MetricConfig struct {
}

type MetricDogStatsD struct {
}

type MultipleEndpointConfig interface {
        GetMultipleEndpoints() (map[string][]string, error)
}

type DogStatsDFactory interface {
        NewServer(aggregator *aggregator.BufferedAggregator, extraTags []string) (*dogstatsd.Server, error)
}

func (m *MetricConfig) GetMultipleEndpoints() (map[string][]string, error) <span class="cov8" title="1">{
        return config.GetMultipleEndpoints()
}</span>

func (m *MetricDogStatsD) NewServer(aggregator *aggregator.BufferedAggregator, extraTags []string) (*dogstatsd.Server, error) <span class="cov8" title="1">{
        return dogstatsd.NewServer(aggregator, extraTags)
}</span>

func buildBufferedAggregator(multipleEndpointConfig MultipleEndpointConfig, forwarderTimeout time.Duration) *aggregator.BufferedAggregator <span class="cov8" title="1">{
        log.Debugf("Using a SyncForwarder with a %v timeout", forwarderTimeout)
        keysPerDomain, err := multipleEndpointConfig.GetMultipleEndpoints()
        if err != nil </span><span class="cov8" title="1">{
                // we're not reporting the error to AWS because we don't want the function
                // execution to be stopped. TODO(remy): discuss with AWS if there is way
                // of reporting non-critical init errors.
                log.Errorf("Misconfiguration of agent endpoints: %s", err)
                return nil
        }</span>
        <span class="cov8" title="1">f := forwarder.NewSyncForwarder(keysPerDomain, forwarderTimeout)
        f.Start() //nolint:errcheck
        serializer := serializer.NewSerializer(f, nil)
        return aggregator.InitAggregator(serializer, nil, "serverless")</span>
}

func (c *ServerlessMetricAgent) Start(forwarderTimeout time.Duration, multipleEndpointConfig MultipleEndpointConfig, dogstatFactory DogStatsDFactory, waitingChan chan bool) <span class="cov8" title="1">{

        // prevents any UDP packets from being stuck in the buffer and not parsed during the current invocation
        // by setting this option to 1ms, all packets received will directly be sent to the parser
        config.Datadog.Set("dogstatsd_packet_buffer_flush_timeout", 1*time.Millisecond)

        aggregatorInstance := buildBufferedAggregator(multipleEndpointConfig, forwarderTimeout)

        if aggregatorInstance != nil </span><span class="cov8" title="1">{
                statsd, err := dogstatFactory.NewServer(aggregatorInstance, nil)
                if err != nil </span><span class="cov8" title="1">{
                        // we're not reporting the error to AWS because we don't want the function
                        // execution to be stopped. TODO(remy): discuss with AWS if there is way
                        // of reporting non-critical init errors.
                        // serverless.ReportInitError(serverlessID, serverless.FatalDogstatsdInit)
                        log.Errorf("Unable to start the DogStatsD server: %s", err)
                }</span> else<span class="cov8" title="1"> {
                        statsd.ServerlessMode = true // we're running in a serverless environment (will removed host field from samples)
                        c.DogStatDServer = statsd
                        c.Aggregator = aggregatorInstance
                }</span>
        }

        <span class="cov8" title="1">waitingChan &lt;- true</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package registration

import (
        "bytes"
        "fmt"
        "net/http"
        "time"
)

const (
        extensionName = "datadog-agent"
        headerExtName = "Lambda-Extension-Name"

        //HeaderExtID is the header name for the extension identifier
        HeaderExtID = "Lambda-Extension-Identifier"
)

// RegisterExtension registers the serverless daemon and subscribe to INVOKE and SHUTDOWN messages.
// Returns either (the serverless ID assigned by the serverless daemon + the api key as read from
// the environment) or an error.
func RegisterExtension(url string, timeout time.Duration) (ID, error) <span class="cov8" title="1">{
        payload := createRegistrationPayload()

        request, err := buildRegisterRequest(headerExtName, extensionName, url, payload)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("registerExtension: can't create the POST register request: %v", err)
        }</span>

        <span class="cov8" title="1">response, err := sendRequest(&amp;http.Client{Timeout: timeout}, request)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("registerExtension: error while POST register route: %v", err)
        }</span>

        <span class="cov8" title="1">if !isAValidResponse(response) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("registerExtension: didn't receive an HTTP 200")
        }</span>

        <span class="cov8" title="1">id := extractID(response)
        if len(id) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("registerExtension: didn't receive an identifier")
        }</span>

        <span class="cov8" title="1">return ID(id), nil</span>
}

func createRegistrationPayload() *bytes.Buffer <span class="cov8" title="1">{
        payload := bytes.NewBuffer(nil)
        payload.Write([]byte(`{"events":["INVOKE", "SHUTDOWN"]}`))
        return payload
}</span>

func extractID(response *http.Response) string <span class="cov8" title="1">{
        return response.Header.Get(HeaderExtID)
}</span>

func isAValidResponse(response *http.Response) bool <span class="cov8" title="1">{
        return response.StatusCode == 200
}</span>

func buildRegisterRequest(headerExtensionName string, extensionName string, url string, payload *bytes.Buffer) (*http.Request, error) <span class="cov8" title="1">{
        request, err := http.NewRequest(http.MethodPost, url, payload)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request.Header.Set(headerExtensionName, extensionName)
        return request, nil</span>
}

func sendRequest(client HTTPClient, request *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        return client.Do(request)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package registration

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/DataDog/datadog-agent/pkg/util/log"
)

const (
        headerContentType string = "Content-Type"
)

// EnableLogsCollection enables logs collections via AWS Logs API
func EnableLogsCollection(
        id ID,
        registrationURL string,
        registrationTimeout time.Duration,
        logsType string,
        port int,
        collectionRoute string,
        timeout int,
        maxBytes int,
        maxItems int) error <span class="cov8" title="1">{

        callBackURI := buildCallbackURI(port, collectionRoute)
        payload := buildLogRegistrationPayload(callBackURI, logsType, timeout, maxBytes, maxItems)

        return subscribeLogs(id, registrationURL, registrationTimeout, payload)
}</span>

// subscribeLogs subscribes to the logs collection on the platform.
// We send a request to AWS to subscribe for logs, indicating on which port we
// are opening an HTTP server, to receive logs from AWS.
// When we are receiving logs on this HTTP server, we're pushing them in a channel
// tailed by the Logs Agent pipeline, these logs then go through the regular
// Logs Agent pipeline to finally be sent on the intake when we receive a FLUSH
// call from the Lambda function / client.
// logsType contains the type of logs for which we are subscribing, possible
// value: platform, extension and function.
func subscribeLogs(id ID, url string, timeout time.Duration, payload json.Marshaler) error <span class="cov8" title="1">{

        jsonBytes, err := payload.MarshalJSON()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("SubscribeLogs: can't marshal subscribe JSON %v", err)
        }</span>

        <span class="cov8" title="1">request, err := buildLogRegistrationRequest(url, HeaderExtID, headerContentType, id, jsonBytes)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("SubscribeLogs: can't create the PUT request: %v", err)
        }</span>

        <span class="cov8" title="1">response, err := sendLogRegistrationRequest(&amp;http.Client{
                Transport: &amp;http.Transport{IdleConnTimeout: timeout},
                Timeout:   timeout,
        }, request)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("SubscribeLogs: while PUT subscribe request: %s", err)
        }</span>

        <span class="cov8" title="1">if !isValidHTTPCode(response.StatusCode) </span><span class="cov8" title="1">{
                return fmt.Errorf("SubscribeLogs: received an HTTP %s", response.Status)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func buildLogRegistrationPayload(callBackURI string, logsType string, timeoutMs int, maxBytes int, maxItems int) *LogSubscriptionPayload <span class="cov8" title="1">{
        logsTypeArray := getLogTypesToSubscribe(logsType)
        log.Debug("Subscribing to Logs for types:", logsTypeArray)
        destination := &amp;destination{
                URI:      callBackURI,
                Protocol: "HTTP",
        }
        buffering := &amp;buffering{
                TimeoutMs: timeoutMs,
                MaxBytes:  maxBytes,
                MaxItems:  maxItems,
        }
        payload := &amp;LogSubscriptionPayload{
                Destination: *destination,
                Types:       logsTypeArray,
                Buffering:   *buffering,
        }
        return payload
}</span>

func buildCallbackURI(httpServerPort int, httpLogsCollectionRoute string) string <span class="cov8" title="1">{
        return fmt.Sprintf("http://sandbox:%d%s", httpServerPort, httpLogsCollectionRoute)
}</span>

func buildLogRegistrationRequest(url string, headerExtID string, headerContentType string, id ID, payload []byte) (*http.Request, error) <span class="cov8" title="1">{
        request, err := http.NewRequest(http.MethodPut, url, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request.Header.Set(headerExtID, id.String())
        request.Header.Set(headerContentType, "application/json")
        return request, nil</span>
}

func sendLogRegistrationRequest(client HTTPClient, request *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        return client.Do(request)
}</span>

func isValidHTTPCode(statusCode int) bool <span class="cov8" title="1">{
        return statusCode &lt; 300
}</span>

func getLogTypesToSubscribe(envLogsType string) []string <span class="cov8" title="1">{
        if len(envLogsType) &gt; 0 </span><span class="cov8" title="1">{
                var logsType []string
                parts := strings.Split(strings.TrimSpace(envLogsType), " ")
                for _, part := range parts </span><span class="cov8" title="1">{
                        part = strings.ToLower(strings.TrimSpace(part))
                        switch part </span>{
                        case "function", "platform", "extension":<span class="cov8" title="1">
                                logsType = append(logsType, part)</span>
                        default:<span class="cov8" title="1">
                                log.Warn("While subscribing to logs, unknown log type", part)</span>
                        }
                }
                <span class="cov8" title="1">return logsType</span>
        }
        <span class="cov8" title="1">return []string{"platform", "function", "extension"}</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package registration

import (
        "encoding/json"
)

type destination struct {
        URI      string `json:"URI"`
        Protocol string `json:"protocol"`
}
type buffering struct {
        MaxBytes  int `json:"maxBytes"`
        MaxItems  int `json:"maxItems"`
        TimeoutMs int `json:"timeoutMs"`
}

// LogSubscriptionPayload is the payload we send while subscribing to the AWS Logs API
type LogSubscriptionPayload struct {
        Buffering   buffering   `json:"buffering"`
        Destination destination `json:"destination"`
        Types       []string    `json:"types"`
}

// MarshalJSON marshals the given LogSubscriptionPayload object
func (p *LogSubscriptionPayload) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // use an alias to avoid infinite recursion while serializing
        type LogSubscriptionPayloadAlias LogSubscriptionPayload
        return json.Marshal((*LogSubscriptionPayloadAlias)(p))
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package registration

import (
        "fmt"
        "net/http"
)

// ID is the extension ID within the AWS Extension environment.
type ID string

// String returns the string value for this ID.
func (i ID) String() string <span class="cov8" title="1">{
        return string(i)
}</span>

// HTTPClient represents an Http Client
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// BuildURL builds and URL with a prefix and a route
func BuildURL(prefix string, route string) string <span class="cov8" title="1">{
        if len(prefix) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("http://localhost:9001%s", route)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("http://%s%s", prefix, route)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package serverless

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/DataDog/datadog-agent/pkg/config"
        "github.com/DataDog/datadog-agent/pkg/serverless/daemon"
        "github.com/DataDog/datadog-agent/pkg/serverless/flush"
        "github.com/DataDog/datadog-agent/pkg/serverless/metrics"
        "github.com/DataDog/datadog-agent/pkg/serverless/registration"
        "github.com/DataDog/datadog-agent/pkg/serverless/tags"
        "github.com/DataDog/datadog-agent/pkg/util/log"
)

const (
        routeEventNext string = "/2020-01-01/extension/event/next"
        routeInitError string = "/2020-01-01/extension/init/error"

        headerExtID      string = "Lambda-Extension-Identifier"
        headerExtErrType string = "Lambda-Extension-Function-Error-Type"

        requestTimeout     time.Duration = 5 * time.Second
        clientReadyTimeout time.Duration = 2 * time.Second

        safetyBufferTimeout time.Duration = 20 * time.Millisecond

        // FatalNoAPIKey is the error reported to the AWS Extension environment when
        // no API key has been set. Unused until we can report error
        // without stopping the extension.
        FatalNoAPIKey ErrorEnum = "Fatal.NoAPIKey"
        // FatalDogstatsdInit is the error reported to the AWS Extension environment when
        // DogStatsD fails to initialize properly. Unused until we can report error
        // without stopping the extension.
        FatalDogstatsdInit ErrorEnum = "Fatal.DogstatsdInit"
        // FatalBadEndpoint is the error reported to the AWS Extension environment when
        // bad endpoints have been configured. Unused until we can report error
        // without stopping the extension.
        FatalBadEndpoint ErrorEnum = "Fatal.BadEndpoint"
        // FatalConnectFailed is the error reported to the AWS Extension environment when
        // a connection failed.
        FatalConnectFailed ErrorEnum = "Fatal.ConnectFailed"

        // Invoke event
        Invoke RuntimeEvent = "INVOKE"
        // Shutdown event
        Shutdown RuntimeEvent = "SHUTDOWN"

        // Timeout is one of the possible ShutdownReasons
        Timeout ShutdownReason = "timeout"
)

// ShutdownReason is an AWS Shutdown reason
type ShutdownReason string

// RuntimeEvent is an AWS Runtime event
type RuntimeEvent string

// ErrorEnum are errors reported to the AWS Extension environment.
type ErrorEnum string

// String returns the string value for this ErrorEnum.
func (e ErrorEnum) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

// String returns the string value for this ShutdownReason.
func (s ShutdownReason) String() string <span class="cov0" title="0">{
        return string(s)
}</span>

// InvocationHandler is the invocation handler signature
type InvocationHandler func(doneChannel chan bool, daemon *daemon.Daemon, arn string, coldstart bool, requestID string)

// Payload is the payload read in the response while subscribing to
// the AWS Extension env.
type Payload struct {
        EventType          RuntimeEvent   `json:"eventType"`
        DeadlineMs         int64          `json:"deadlineMs"`
        InvokedFunctionArn string         `json:"invokedFunctionArn"`
        ShutdownReason     ShutdownReason `json:"shutdownReason"`
        RequestId          string         `json:"requestId"`
}

// ReportInitError reports an init error to the environment.
func ReportInitError(id registration.ID, errorEnum ErrorEnum) error <span class="cov0" title="0">{
        var err error
        var content []byte
        var request *http.Request
        var response *http.Response

        if content, err = json.Marshal(map[string]string{
                "error": string(errorEnum),
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ReportInitError: can't write the payload: %s", err)
        }</span>

        <span class="cov0" title="0">if request, err = http.NewRequest(http.MethodPost, buildURL(routeInitError), bytes.NewBuffer(content)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ReportInitError: can't create the POST request: %s", err)
        }</span>

        <span class="cov0" title="0">request.Header.Set(headerExtID, id.String())
        request.Header.Set(headerExtErrType, FatalConnectFailed.String())

        client := &amp;http.Client{
                Transport: &amp;http.Transport{IdleConnTimeout: requestTimeout},
                Timeout:   requestTimeout,
        }

        if response, err = client.Do(request); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ReportInitError: while POST init error route: %s", err)
        }</span>

        <span class="cov0" title="0">if response.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("ReportInitError: received an HTTP %s", response.Status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WaitForNextInvocation makes a blocking HTTP call to receive the next event from AWS.
// Note that for now, we only subscribe to INVOKE and SHUTDOWN events.
// Write into stopCh to stop the main thread of the running program.
func WaitForNextInvocation(stopCh chan struct{}, daemon *daemon.Daemon, id registration.ID, coldstart bool) error <span class="cov0" title="0">{
        var err error
        var request *http.Request
        var response *http.Response

        if request, err = http.NewRequest(http.MethodGet, buildURL(routeEventNext), nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WaitForNextInvocation: can't create the GET request: %v", err)
        }</span>
        <span class="cov0" title="0">request.Header.Set(headerExtID, id.String())

        // make a blocking HTTP call to wait for the next event from AWS
        log.Debug("Waiting for next invocation...")
        client := &amp;http.Client{Timeout: 0} // this one should never timeout
        if response, err = client.Do(request); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WaitForNextInvocation: while GET next route: %v", err)
        }</span>

        <span class="cov0" title="0">daemon.FinishInvocationOnce = sync.Once{}

        // we received an INVOKE or SHUTDOWN event
        daemon.StoreInvocationTime(time.Now())

        var body []byte
        if body, err = ioutil.ReadAll(response.Body); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WaitForNextInvocation: can't read the body: %v", err)
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        var payload Payload
        if err := json.Unmarshal(body, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WaitForNextInvocation: can't unmarshal the payload: %v", err)
        }</span>

        <span class="cov0" title="0">if payload.EventType == Invoke </span><span class="cov0" title="0">{
                callInvocationHandler(daemon, payload.InvokedFunctionArn, payload.DeadlineMs, safetyBufferTimeout, coldstart, payload.RequestId, handleInvocation)
        }</span>
        <span class="cov0" title="0">if payload.EventType == Shutdown </span><span class="cov0" title="0">{
                log.Debug("Received shutdown event. Reason: " + payload.ShutdownReason)
                isTimeout := strings.ToLower(payload.ShutdownReason.String()) == Timeout.String()
                if isTimeout </span><span class="cov0" title="0">{
                        metricTags := tags.AddColdStartTag(daemon.ExtraTags.Tags, coldstart)
                        metricsChan := daemon.MetricAgent.Aggregator.GetBufferedMetricsWithTsChannel()
                        metrics.SendTimeoutEnhancedMetric(metricTags, metricsChan)
                }</span>
                <span class="cov0" title="0">daemon.Stop(isTimeout)
                stopCh &lt;- struct{}{}</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func callInvocationHandler(daemon *daemon.Daemon, arn string, deadlineMs int64, safetyBufferTimeout time.Duration, coldstart bool, requestID string, invocationHandler InvocationHandler) <span class="cov8" title="1">{
        timeout := computeTimeout(time.Now(), deadlineMs, safetyBufferTimeout)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        doneChannel := make(chan bool)
        go invocationHandler(doneChannel, daemon, arn, coldstart, requestID)
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                log.Debug("Timeout detected, finishing the current invocation now to allow receiving the SHUTDOWN event")
                daemon.FinishInvocation()
                return</span>
        case &lt;-doneChannel:<span class="cov0" title="0">
                return</span>
        }
}

func handleInvocation(doneChannel chan bool, daemon *daemon.Daemon, arn string, coldstart bool, requestID string) <span class="cov8" title="1">{
        daemon.StartInvocation()
        log.Debug("Received invocation event...")
        daemon.ComputeGlobalTags(arn, config.GetConfiguredTags(true))
        daemon.SetExecutionContext(arn, requestID)
        if coldstart </span><span class="cov8" title="1">{
                ready := daemon.WaitUntilClientReady(clientReadyTimeout)
                if ready </span><span class="cov0" title="0">{
                        log.Debug("Client library registered with extension")
                }</span> else<span class="cov0" title="0"> {
                        log.Debug("Timed out waiting for client library to register with extension.")
                }</span>
                <span class="cov0" title="0">daemon.UpdateStrategy()</span>
        }

        // immediately check if we should flush data
        // note that since we're flushing synchronously here, there is a scenario
        // where this could be blocking the function if the flush is slow (if the
        // extension is not quickly going back to listen on the "wait next event"
        // route). That's why we use a context.Context with a timeout `flushTimeout``
        // to avoid blocking for too long.
        // This flushTimeout is re-using the forwarder_timeout value.
        <span class="cov0" title="0">if daemon.FlushStrategy.ShouldFlush(flush.Starting, time.Now()) </span><span class="cov0" title="0">{
                log.Debugf("The flush strategy %s has decided to flush the data in the moment: %s", daemon.FlushStrategy, flush.Starting)
                flushTimeout := config.Datadog.GetDuration("forwarder_timeout") * time.Second
                ctx, cancel := context.WithTimeout(context.Background(), flushTimeout)
                daemon.TriggerFlush(ctx, false)
                cancel() // free the resource of the context
        }</span> else<span class="cov0" title="0"> {
                log.Debugf("The flush strategy %s has decided to not flush in the moment: %s", daemon.FlushStrategy, flush.Starting)
        }</span>
        <span class="cov0" title="0">daemon.WaitForDaemon()
        doneChannel &lt;- true</span>
}

func buildURL(route string) string <span class="cov0" title="0">{
        prefix := os.Getenv("AWS_LAMBDA_RUNTIME_API")
        if len(prefix) == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("http://localhost:9001%s", route)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("http://%s%s", prefix, route)</span>
}

func computeTimeout(now time.Time, deadlineMs int64, safetyBuffer time.Duration) time.Duration <span class="cov8" title="1">{
        currentTimeInMs := now.UnixNano() / int64(time.Millisecond)
        return time.Duration((deadlineMs-currentTimeInMs)*int64(time.Millisecond) - int64(safetyBuffer))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package tags

import (
        "fmt"
        "os"
        "strings"
)

const (
        qualifierEnvVar = "AWS_LAMBDA_FUNCTION_VERSION"

        traceOriginMetadataKey   = "_dd.origin"
        traceOriginMetadataValue = "lambda"
        computeStatsKey          = "_dd.compute_stats"
        computeStatsValue        = "1"
        functionARNKey           = "function_arn"
        functionNameKey          = "functionname"
        regionKey                = "region"
        accountIDKey             = "account_id"
        awsAccountKey            = "aws_account"
        resourceKey              = "resource"
        executedVersionKey       = "executedversion"
)

func BuildTagMap(arn string, configTags []string) map[string]string <span class="cov8" title="1">{
        tags := make(map[string]string)

        for _, tag := range configTags </span><span class="cov8" title="1">{
                splitTags := strings.Split(tag, ",")
                for _, singleTag := range splitTags </span><span class="cov8" title="1">{
                        tags = addTag(tags, singleTag)
                }</span>
        }

        <span class="cov8" title="1">tags = setIfNotEmpty(tags, traceOriginMetadataKey, traceOriginMetadataValue)
        tags = setIfNotEmpty(tags, computeStatsKey, computeStatsValue)
        tags = setIfNotEmpty(tags, functionARNKey, arn)

        parts := strings.Split(arn, ":")
        if len(parts) &lt; 6 </span><span class="cov8" title="1">{
                return tags
        }</span>

        <span class="cov8" title="1">tags = setIfNotEmpty(tags, regionKey, parts[3])
        tags = setIfNotEmpty(tags, awsAccountKey, parts[4])
        tags = setIfNotEmpty(tags, accountIDKey, parts[4])
        tags = setIfNotEmpty(tags, functionNameKey, parts[6])
        tags = setIfNotEmpty(tags, resourceKey, parts[6])

        qualifier := os.Getenv(qualifierEnvVar)
        if len(qualifier) &gt; 0 </span><span class="cov8" title="1">{
                if qualifier != "$LATEST" </span><span class="cov8" title="1">{
                        tags = setIfNotEmpty(tags, resourceKey, fmt.Sprintf("%s:%s", parts[6], qualifier))
                        tags = setIfNotEmpty(tags, executedVersionKey, qualifier)
                }</span>
        }

        <span class="cov8" title="1">return tags</span>
}

func BuildTagsFromMap(tags map[string]string) []string <span class="cov8" title="1">{
        tagsMap := make(map[string]string)
        tagBlackList := []string{traceOriginMetadataKey, computeStatsKey}
        for k, v := range tags </span><span class="cov8" title="1">{
                tagsMap[k] = v
        }</span>
        <span class="cov8" title="1">for _, blackListKey := range tagBlackList </span><span class="cov8" title="1">{
                delete(tagsMap, blackListKey)
        }</span>
        <span class="cov8" title="1">tagsArray := make([]string, 0, len(tagsMap))
        for key, value := range tagsMap </span><span class="cov8" title="1">{
                tagsArray = append(tagsArray, fmt.Sprintf("%s:%s", key, value))
        }</span>
        <span class="cov8" title="1">return tagsArray</span>
}

func BuildTracerTags(tags map[string]string) map[string]string <span class="cov8" title="1">{
        tagsMap := make(map[string]string)
        tagBlackList := []string{resourceKey}
        for k, v := range tags </span><span class="cov8" title="1">{
                tagsMap[k] = v
        }</span>
        <span class="cov8" title="1">for _, blackListKey := range tagBlackList </span><span class="cov8" title="1">{
                delete(tagsMap, blackListKey)
        }</span>
        <span class="cov8" title="1">return tagsMap</span>
}

func setIfNotEmpty(tagMap map[string]string, key string, value string) map[string]string <span class="cov8" title="1">{
        if key != "" </span><span class="cov8" title="1">{
                tagMap[key] = strings.ToLower(value)
        }</span>
        <span class="cov8" title="1">return tagMap</span>
}

func addTag(tagMap map[string]string, tag string) map[string]string <span class="cov8" title="1">{
        extract := strings.Split(tag, ":")
        if len(extract) == 2 </span><span class="cov8" title="1">{
                tagMap[strings.ToLower(extract[0])] = strings.ToLower(extract[1])
        }</span>
        <span class="cov8" title="1">return tagMap</span>
}

// AddColdStartTag appends the cold_start tag to existing tags
func AddColdStartTag(tags []string, coldStart bool) []string <span class="cov8" title="1">{
        tags = append(tags, fmt.Sprintf("cold_start:%v", coldStart))
        return tags
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
